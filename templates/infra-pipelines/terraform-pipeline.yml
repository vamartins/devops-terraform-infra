variables:
  AWS_DEPLOYMENT_ROLE: "tuigroup-onesource-deployment-role"
  TERRAFORM_DIRECTORY_NAME: "infra"
  TERRAFORM_DIRECTORY_NAME_VARIABLES: "envs"
  REPLACE_PATTERN: "#pipeline:replace:"

.base_terraform:
  before_script:
    # Add authentication for Git URLs (e.g. in Terraform)
    - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@source.tui".insteadOf https://source.tui
    - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@source.tui".insteadOf ssh://git@ssh.source.tui

    # Possibility to add own SSH keys to the pipeline as environment variable
    - if [ -n "$SSH_PRIVATE_KEY_PIPELINE" ]; then eval $(ssh-agent -s); echo "$SSH_PRIVATE_KEY_PIPELINE" | tr -d '\r' | ssh-add - > /dev/null; fi
    - if [ -n "$SSH_PRIVATE_KEY_PIPELINE" ]; then mkdir -p ~/.ssh; chmod 700 ~/.ssh; echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config; fi

    # Manipulate the identifier lines, so that we can use the part after the identifier for the pipeline
    - find $CI_PROJECT_DIR/ -type f -exec sed -i -e "s/.*$REPLACE_PATTERN//g" {} \;

    - cd $CI_PROJECT_DIR/$TERRAFORM_DIRECTORY_NAME && terraform init
    - terraform workspace select $CI_ENVIRONMENT_NAME || terraform workspace new $CI_ENVIRONMENT_NAME
    - export TF_VAR_environment=$CI_ENVIRONMENT_NAME
    - export TF_VAR_aws_deployment_role=$AWS_DEPLOYMENT_ROLE

.plan_terraform:
  extends: .base_terraform
  stage: plan
  script:
    - terraform validate
    - terraform plan -var-file=$TERRAFORM_DIRECTORY_NAME_VARIABLES/$CI_ENVIRONMENT_NAME.tfvars -out "$CI_ENVIRONMENT_NAME.tfplan"
  # per default all artifacts from previous stages are passed https://docs.gitlab.com/ee/ci/yaml/#dependencies
  artifacts:
    paths:
      - $TERRAFORM_DIRECTORY_NAME/$CI_ENVIRONMENT_NAME.tfplan

.deploy_terraform:
  extends: .base_terraform
  stage: deploy
  script:
    - terraform apply -input=false -auto-approve "$CI_ENVIRONMENT_NAME.tfplan"

.destroy_terraform:
  extends: .base_terraform
  stage: destroy
  script:
    - terraform destroy -input=false -auto-approve -var-file=$TERRAFORM_DIRECTORY_NAME_VARIABLES/$CI_ENVIRONMENT_NAME.tfvars

#------------------------------------------------
# backends using the GitLab provided http backend
#------------------------------------------------

.base_terraform_http:
  image:
    name: hashicorp/terraform:1.0.4
    entrypoint: [""]
  variables:
    # this is also a nice addition if you have multiple infrastructure directories and terraform code locations
    # will also not do anything if ignored :)
    CODE_PATH: ""
    TF_STATE: ${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}
    TF_ADDRESS: ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state
  before_script:
    - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@source.tui".insteadOf https://source.tui
    - git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@source.tui".insteadOf ssh://git@ssh.source.tui
    - export TF_VAR_aws_deployment_role=$AWS_DEPLOYMENT_ROLE
    # this is some stuff Future Markets repos use fairly often for unique names in case of long branch
    # names, this should not collide with anyone else unless they specify the short_ref variable
    # that seems unlikely to me right now :)
    - export TF_VAR_short_ref=$(echo $CI_COMMIT_REF_NAME | cut -d "_" -f 1)
    - cd $TERRAFORM_DIRECTORY_NAME/$CODE_PATH
    - echo "Base state address for this repository ${TF_ADDRESS}"
    - echo "Using ${TF_STATE} as the specific statekey"
    - echo "Full state path ${TF_ADDRESS}/${TF_STATE}"
    - terraform init
      --backend-config="address=${TF_ADDRESS}/${TF_STATE}"
      --backend-config="lock_address=${TF_ADDRESS}/${TF_STATE}/lock"
      --backend-config="unlock_address=${TF_ADDRESS}/${TF_STATE}/lock"
      --backend-config="username=gitlab-ci-token"
      --backend-config="password=${CI_JOB_TOKEN}"
      --backend-config="lock_method=POST"
      --backend-config="unlock_method=DELETE"
      --backend-config="retry_wait_min=5"

.validate_terraform_http:
  extends: .base_terraform_http 
  script:
    - terraform validate

.plan_terraform_http:
  extends: .base_terraform_http 
  script:
    - terraform validate
    - terraform plan

# the notification script thing was kind of cool so I left it in - once we have a readme for this we could
# show how to set that up, for now it won't do anything if the script does not exist
.deploy_terraform_http:
  extends: .base_terraform_http
  script:
    - export NOTIFICATION_SCRIPT=$CI_PROJECT_DIR/deployment_notification.sh
    - if [ -f $NOTIFICATION_SCRIPT ];then $NOTIFICATION_SCRIPT "planned";fi
    - if [ -f $NOTIFICATION_SCRIPT ];then terraform apply -auto-approve -no-color || ($NOTIFICATION_SCRIPT "failed" && false); else terraform apply -auto-approve -no-color;fi
    - if [ -f $NOTIFICATION_SCRIPT ];then $NOTIFICATION_SCRIPT "successful";fi

.destroy_terraform_http:
  extends: .base_terraform_http
  script:
    - terraform destroy -auto-approve -no-color
